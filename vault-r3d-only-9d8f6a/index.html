<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>?</title>
  <meta name="robots" content="noindex,nofollow" />
  <style>
    :root {
      --bg: #0a0a0a;
      --fg: #f3f3f3;
      --muted: #9a9a9a;
      --card: rgba(0, 0, 0, 0.55);
      --accent: #ff1a1a;
      --stroke: rgba(255, 255, 255, 0.08);
      --glow: 0 0 24px rgba(255, 26, 26, 0.25);
      --font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Inter, Roboto, Arial, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font: 16px/1.5 var(--font);
      color: var(--fg);
      background: var(--bg);
      display: grid;
      place-items: center;
    }

    main.card {
      width: min(880px, 92vw);
      padding: 28px;
      border-radius: 12px;
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
    }

    h1 {
      margin: 0 0 8px;
      font-size: 20px;
    }

    p {
      margin: 0 0 16px;
      color: var(--muted);
    }

    .gate {
      display: flex;
      gap: 10px;
      margin-top: 14px;
    }

    .pin {
      flex: 1;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background: transparent;
      color: var(--fg);
      outline: none;
      font-size: 16px;
    }

    .btn {
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255, 26, 26, 0.12), rgba(255, 26, 26, 0.06));
      color: var(--fg);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .btn:hover {
      box-shadow: var(--glow);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .msg {
      margin-top: 10px;
      color: #ffb3b3;
      font-size: 14px;
      min-height: 18px;
    }
  </style>
</head>
<body>
  <main class="card" role="main" aria-labelledby="vault-title">
    <h1 id="vault-title">Strefa prywatna</h1>
    <p>Wpisz hasło, żeby przejść dalej.</p>

    <div class="gate">
      <input id="vault-pass" class="pin" type="password" inputmode="text" placeholder="Wpisz hasło" autocomplete="off" aria-label="Hasło" />
      <button id="vault-submit" class="btn" type="button">Wejdź</button>
    </div>

    <div id="vault-msg" class="msg" role="status" aria-live="polite"></div>
  </main>

  <script>
    (() => {
      'use strict';

      const ITERATIONS = 200000;
      const TOKEN_KEY = 'dreiji.once.token';
      const PATH_KEY = 'dreiji.once.path';
      const LOCK_KEY = 'vlt_lock';
      const MAX_FAILS = 5;
      const LOCKOUT_MS = 30_000;

      const entries = [
        {
          salt: 'oZ7bzZfZuBNJnr6HsHcdAg==',
          iv: 'q+7qOFzi73M1vNSN',
          ct: 'Nufafun4ARmYwiyJUasx/8OjIfumGPf5i4R8O4G5Z97hSaIxd8/7eJYZet4wujhBxs1cN03nkgOazzDueixarVWy9Kmm9WSAXoiBdg=='
        },
        {
          salt: 'x4+jnl4Xb5GZ7JvTyfu99A==',
          iv: 'zrk5fC6E/lvTMkYF',
          ct: 'BtKdHPgITnY5v1HbCNEeBPnhIv8Hg1HWsW3Nu/tlx8beNM6n1FH0fyM+LMukR1p3D5v7wCF6HrMvMFI='
        }
      ].map((entry) => ({
        salt: Uint8Array.from(atob(entry.salt), (c) => c.charCodeAt(0)),
        iv: Uint8Array.from(atob(entry.iv), (c) => c.charCodeAt(0)),
        ct: Uint8Array.from(atob(entry.ct), (c) => c.charCodeAt(0))
      }));

      const encoder = new TextEncoder();
      const decoder = new TextDecoder();

      const passField = document.getElementById('vault-pass');
      const submitBtn = document.getElementById('vault-submit');
      const message = document.getElementById('vault-msg');

      sessionStorage.removeItem(TOKEN_KEY);
      sessionStorage.removeItem(PATH_KEY);

      let fails = 0;
      let lockUntil = Number(sessionStorage.getItem(LOCK_KEY) || 0);

      if (lockUntil > Date.now()) {
        message.textContent = `(${Math.ceil((lockUntil - Date.now()) / 1000)}s)`;
      } else if (lockUntil) {
        sessionStorage.removeItem(LOCK_KEY);
        lockUntil = 0;
      }

      function toHex(bytes) {
        return Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('');
      }

      async function deriveUrl(pass) {
        const material = await crypto.subtle.importKey('raw', encoder.encode(pass), { name: 'PBKDF2' }, false, ['deriveKey']);

        for (const entry of entries) {
          try {
            const key = await crypto.subtle.deriveKey(
              { name: 'PBKDF2', hash: 'SHA-256', iterations: ITERATIONS, salt: entry.salt },
              material,
              { name: 'AES-GCM', length: 256 },
              false,
              ['decrypt']
            );

            const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: entry.iv }, key, entry.ct);
            return decoder.decode(plaintext);
          } catch (error) {
            // try next entry
          }
        }

        return null;
      }

      function cleanPath(url) {
        return url.replace(/\/+$/, '');
      }

      function lock() {
        lockUntil = Date.now() + LOCKOUT_MS;
        sessionStorage.setItem(LOCK_KEY, String(lockUntil));
        message.textContent = 'Zbyt wiele prób, odczekaj.';
        fails = 0;
      }

      async function submit() {
        const now = Date.now();
        if (now < lockUntil) {
          message.textContent = `(${Math.ceil((lockUntil - now) / 1000)}s)`;
          return;
        }

        const raw = (passField.value || '').trim();
        if (!raw) {
          message.textContent = 'Wpisz hasło.';
          return;
        }

        message.textContent = '';

        const destination = await deriveUrl(raw);
        if (!destination) {
          fails += 1;
          passField.value = '';
          passField.focus();
          if (fails >= MAX_FAILS) {
            lock();
          } else {
            message.textContent = 'Złe hasło.';
          }
          return;
        }

        sessionStorage.removeItem(LOCK_KEY);

        try {
          const target = new URL(destination, window.location.href);
          const tokenBytes = crypto.getRandomValues(new Uint8Array(12));
          const token = toHex(tokenBytes);
          sessionStorage.setItem(TOKEN_KEY, token);
          sessionStorage.setItem(PATH_KEY, cleanPath(target.pathname));
          target.hash = token;
          window.location.assign(target.href);
        } catch (error) {
          window.location.assign(destination);
        }
      }

      submitBtn.addEventListener('click', submit);
      passField.addEventListener('keyup', (event) => {
        if (event.key === 'Enter') {
          submit();
        }
      });
    })();
  </script>
</body>
</html>
